
from secretsharing import Fp, Poly
import gevent
from gevent.event import AsyncResult
from collections import defaultdict
import random
import secretsharing


########################
# MPC Protocol Simulator
########################

"""
This implementation of MPC is provided for you, you don't need
to do any work to complete it.  (As you complete other parts,
there are a couple of options you may want to comment out, these
are marked with TODO so you can find them easily).

The MPC simulator takes in an MPC program "prog" as input. The
idea is that the simulator runs "prog" n times, once for each of
MPC nodes.

You can provide secret shared inputs to the program in the form of 
input_table. These inputs get turned into secret shared values (the
individual nodes do not receive the actual input, instead a secret
shared encoding of the input).

In reality, MPC nodes would communicate to each other over secure
sockets. For the simulator, we just implement a simple switching
system. Each MPC node has access to a method,

  - context.open_share(v),

which broadcasts the share v to every other node, and waits to 
receive n shares from the other nodes. After this, it attempts
to reconstruct the share using decoding functions from secretsharing
modules.

The simulator also creates some preprocessing data, specifically
shares of random field elements and shares of random multiplication
triples. In reality, these would need to be generated by an
offline phase.

Each of the n nodes runs in its own lightweight "greenthread", using
the gevent library. This is cooperative multi-tasking, control passes
to another node only in the open_share() function is the only method 
that blocks. You shouldn't have to worry about this - if your code
throws an exception, you may see multiple copies of the error printed,
once for each node.

"""

class MPCSimulation():
    def __init__(self, n, f, input_table, prog, corrupt=0, crashed=0, preproc=5):
        print('Running sample program n:', n, 'f:', f, 'corrupt:', corrupt, prog, 'input_table:', input_table)
        # Runs N instances of prog, tolerating f faults,
        # passing input shares from input_table
        self.nodes = []

        # For each value in input_table, generate a random polynomial
        # with this as the intercept
        poly_table = {}
        for k,v in input_table.items():
            assert type(v) in (int, int)
            poly_table[k] = Poly.random_with_intercept(v, f)

        # Openings will map from shareid => [AsyncResult, ... x N]
        self.received_shares = defaultdict(lambda: [AsyncResult() for _ in range(n)])

        # Preprocessing ingredients
        if preproc is None:
            N_PREPROCESSING = self.f * 5 # a default that works for minimal cases
        else:
            N_PREPROCESSING = preproc

        # TRIPLES
        for k in range(N_PREPROCESSING):
            a = Fp(random.randint(0, Fp.p-1))
            b = Fp(random.randint(0, Fp.p-1))
            ab = a*b
            poly_table[('_triples', 3*k+0)] = Poly.random_with_intercept(a , f)
            poly_table[('_triples', 3*k+1)] = Poly.random_with_intercept(b , f)
            poly_table[('_triples', 3*k+2)] = Poly.random_with_intercept(ab, f)

        # RANDOMS
        for k in range(N_PREPROCESSING):
            a = Fp(random.randint(0, Fp.p-1))
            poly_table[('_randoms', k)] = Poly.random_with_intercept(a, f)

        # Optionally simulate up to f corruptions
        if corrupt or crashed:
            fail_ids = list(range(1,n))
            random.shuffle(fail_ids)
            fail_ids = fail_ids[:f]
            print('failed node ids:', fail_ids)

        # Communication between nodes
        def make_send_share(i):
            shareid = [0]
            def _send_share(share):
                assert type(share) is Fp
                # Set this result so it is available
                self.received_shares[shareid[0]][i].set(share)
                shareid[0] += 1
            return _send_share

        def make_wait_for_shares(i):
            shareid = [0]
            def _wait_for_shares():
                # Block and wait for all N results to be available
                shares = [self.received_shares[shareid[0]][j].get() for j in range(n)]

                # Optionally simulate corruptions or crashes
                if corrupt and i == 0:
                    for c in fail_ids:
                        shares[c] = Fp(random.randint(0,Fp.p-1))
                if crashed and i == 0:
                    for c in fail_ids:
                        shares[c] = None
                    
                shareid[0] += 1
                return shares
            return _wait_for_shares

        # Create each node
        for i in range(n):
            # Make inputs and sends for this node
            table = dict((k,P(Fp(i+1))) for k,P in poly_table.items())
            send_share = make_send_share(i)
            wait_for_shares = make_wait_for_shares(i)
            node = MPCNode(n, f, i, prog, wait_for_shares, send_share, table)
            self.nodes.append(node)            

    def run(self):
        threads = [n._run() for n in self.nodes]
        gevent.joinall(threads)
        results = [t.get() for t in threads]
        return results

class MPCNode():
    def __init__(self, n, f, myid, prog, wait_for_shares, send_share, share_table):
        self.n = n
        self.f = f
        self.myid = myid
        self._prog = prog
        self._send_share = send_share
        self._wait_for_shares = wait_for_shares
        self.share_table = share_table
        self._triples_taken = 0
        self._randoms_taken = 0

    def _run(self):
        # Run the program, using itself as a context
        self._thread = gevent.spawn(self._prog, self)
        return self._thread

    def open_share(self, v):
        assert type(v) is Fp
        self._send_share(v)
        # Wait for N shares to be ready
        # - Some of the shares may be None
        #    This corresponds to a crashed node. We can treat this as an erasure
        # - Some shares may be incorrect

        shares = self._wait_for_shares()
        shares = [(Fp(i+1), y) if y is not None else y
                  for i,y in enumerate(shares)]
        # Ensure shares are in the form (x,y) or None
        # self.print('open_share: shares=', shares)

        ####################################
        # Note: a few TODOs for you are here
        ####################################

        # Option 1: Attempt to decode all the values
        # opened = secretsharing.decode_shares(self.n, self.f, shares)

        # This form of interpolation is fine for the passive-attack case
        # But it's not sufficient for a world with corruptions

        # TODO: As you complete Problem 4.1 and 4.2 in secretsharing,
        # you can uncomment Option 2 or Option 3
        
        # Option 2: To handle crash faults, attempt to decode using
        # only f+1 values (whichever ones are not None)
        # opened = secretsharing.decode_with_erasures(self.n, self.f, shares)

        # Option 3: To handle corruption faults,
        #  we need to find a subset of f+1 values, such that when we 
        #  interpolate the polynomial at every point, the resulting
        #  polynomial coincides with 2f+1 values
        # opened = secretsharing.decode_with_errors(self.n, self.f, shares)
        
        return opened

    # Access to preprocessing data
    def get_random_share(self):
        assert ('_randoms',self._randoms_taken) in self.share_table, "preprocess underrun!"
        share = self.share_table[('_randoms', self._randoms_taken)]
        self._randoms_taken += 1
        return share

    def get_triple_share(self):
        assert ('_triples',self._triples_taken+2) in self.share_table, "preprocess underrun!"
        a  = self.share_table[('_triples', self._triples_taken+0)]
        b  = self.share_table[('_triples', self._triples_taken+1)]
        ab = self.share_table[('_triples', self._triples_taken+2)]
        self._triples_taken += 3
        return a, b, ab

    def print(self, *args, **kwargs):
        print('{%d}' % (self.myid,), *args, **kwargs)


####################################
# Problem 2.1: Beaver multiplication  [5pts]
####################################
"""
Goal:
  Given [x] and [y], compute [xy].

  Just multiplying the shares together, [x] * [y], would give a
  degree-2t polynomial, which can't be recovered directly.

  Beaver Multiplication approch makes use of a preprocessed
  "beaver triple" of shared values, [a], [b], and [ab], which
  are used once in this protocol and then discarded.
"""

def beaver_multiply(context, x, y):
    assert type(x) is Fp
    assert type(y) is Fp
    xy = Fp(1)

    # Get a fresh beaver triple
    a, b, ab = context.get_triple_share()

    # TODO: Your code goes here

    return xy

def test_prog_beaver_multiply(context):
    x = context.share_table['x']
    y = context.share_table['y']
    xy = beaver_multiply(context, x, y)
    assert context.open_share(xy) == context.open_share(x) * context.open_share(y)
    # context.print("test_prog1 OK")


#######################################
# Problem 2.2: Computing an inverse     [5pts]
#######################################

"""
Goal:
  Given [x], compute [1/x]

Note that we cannot just take the obvious approach, of inverting
the share directly,
   [1/x]  =/=  1/[x]
See more below at "Illustration"

How else can you compute [1/x] without revealing x?
"""
def test_prog_inverses(context):
    x = context.get_random_share()

    # Compute the ground truth by actually opening x then computing 1/x
    # (Note: This leaks the value x - it does not count as a secure way
    # to compute [1/x] from [x].
    X = context.open_share(x)
    assert X != 0
    invX_truth = Fp(1) / X

    # Illustration:
    # Try to compute [1/x] the obvious way, as 1/[x].
    # Change the "if 0:" below to "if 1:" below to see that it does
    # not work
    invx = Fp(1) / x
    if 0: # Change to 1 to see
        try:
            invX = context.open_share(invx)
            assert invX == invX_truth, "Naive inverse failed (as expected): invX:%o, invX_truth:%o" % (invX, invX_truth)
        except AssertionError as e:
            print(e)
            pass # Expected

    # Check that inverse of x multiplies correctly
    invx = compute_inverse(context, x)
    invX = context.open_share(invx)
    assert context.open_share(invx) == invX_truth, "Failed. invX:%o, invX_truth:%o" % (invX, invX_truth)

def compute_inverse(context, x):
    invx = Fp(0)
    # TODO: Your code goes here
    return invx


#######################################
# Problem 2.3: Generating random bits   [5pts]
#######################################

"""
Goal: 
   Compute a random bit [b] such that b is 0 or 1

Given that p is an odd prime, in Zp* half the values are squares,
the other half are non-squares
http://www.math.uconn.edu/~kconrad/blurbs/ugradnumthy/QuadraticResiduePatterns.pdf

Here's a fact about squares in finite fields, multiplication still distributes
over addition, and so
    x^2 == (-x)^2   still holds

We have an algorithm for finding the square root of r
if it has one, see prime_mod_sqrt.py to see how it works.
To use it, simply do prime_mod_sqrt(r) where r is a field elment.
However, prime_mode_sqrt([r]) will not give you [prime_mod_sqrt(r)].

Fortunately, the fact mentioned above can be used to
work out a way to extract a random bit from $\share{r}$.

See if you can think of it yourself, but for spoilers see
the following

References:
https://www.iacr.org/archive/pkc2007/44500343/44500343.pdf
Section 3, "Joint Random Bit Sharing."

"""
def get_random_bit(context):
    from prime_mod_sqrt import prime_mod_sqrt

    # Start by drawing a random [r]
    r = context.get_random_share()
    b = Fp(-1)

    # TODO: Your code goes here

    return b

def test_prog_random_bits(context):
    # Check all bits are 0 or 1
    for _ in range(5):
        b = get_random_bit(context)
        B = context.open_share(b)
        if context.myid == 0:
            context.print('open(bit):', B)
        assert B in (0,1)

    # Optional improvement: run statistical tests?

    context.print("test_prog1 OK")


################################################
# Problem 2.4 Computing powers in constant round [10pts]
################################################

"""
Goal:
  Given k and [x], compute the first k powers of [x],
  so [1],[x],[x^2],[x^3],...[x^k]

Sure, we can do this using beaver triples. But this 
requires many sequential computations. Our goal is a 
protocol for computing this with only constant trips 
of communication.

References:
https://www.iacr.org/archive/tcc2006/38760286/38760286.pdf
Section 2.1, Unbounded fan-in multiplication

"""

def compute_powers(context, x, k):
    # Compute [r0],...[rk]
    rs = [context.get_random_share() for _ in range(k+1)]
    xis = []

    # TODO: your code goes here
    return xis


def test_prog_constant_round_powers(context):
    k = 10 # Compute 10 values
    x = context.share_table['x']

    # Sure, we can could compute products directly, but
    # this requires many sequential computations. Our goal
    # is a protocol for computing this with only constant
    # trips of communication
    if 1:
        xs = [x]
        for i in range(1,k):
            xs.append(beaver_multiply(context, x, xs[-1]))
            
    # Now call the compute_powers function
    xs = compute_powers(context, x, k)
    assert len(xs) == k

    X = context.open_share(x)
    for i, xi in zip(list(range(1,k+1)), xs):
        assert context.open_share(xi) == X ** i
    

####################################
# Problem 2.5: Randomness extraction [5pts]
####################################

"""
Goal:
  Given [a1], [a2], ... [aN], 
     one value contributed by each of the N parties,
  output random shares [b1, ... bN-f] 
     that no one knows

The idea is to consider interpolating a polynomial through
each of the points, 
   phi(1) = [a1], ...., phi(N) = [aN]

Then we can interpolate the polynomial at (N-f) additional
points.
   [b1] = phi(N+1), ...., phi(2N-f)

It turns out you can reuse the same polynomial interpolation
routines you have, even though you'll interpolating shares of the
form (x,[y]). This will work because interpolation is a linear
function of the [y] values.
"""

def random_extract(context, avals):
    assert len(avals) == context.n


def test_prog_random_extract(context):
    # Simluate a value contributed by each party
    # Note: f of the values may be non-random, or known to the adversary
    avals = [context.get_random_share() for _ in range(context.n)]

    # Derive random values from these
    extracted = random_extract(context, avals)

    # Compare with ground truth
    aopens = list(map(context.open_share, avals)) # open all a values
    points = [(Fp(i+1), aopens[i]) for i in range(len(aopens))]
    phi = Poly.interpolate(points)
    ground_truth = [phi(Fp(context.n+i+1)) for i in range(context.n-context.f)]
    opened = list(map(context.open_share, extracted))
    assert ground_truth == opened
                           

########################
# Problem 5: Extras
########################

"""
 Here are several ideas for what to do next.
 Earn up to 5 bonus points for tackling one or more of these.

 5.1. Computing with double sharings instead of beaver triples
   - Add a new method to open degree-2t data.
   - Add a new prepcoressing type, rand double sharing,
     Which returns [r]_t and [r]_2t, both are random sharings
     for same random value r.
   - You can now use these to decode [x]_t from [x]_2t
   - This can be used to compute dot products very efficiently

 5.2. Implement the probabilistic equality testing operation from
   - https://www.iacr.org/archive/pkc2007/44500343/44500343.pdf
     6.5 Probabilistic Equality Test Protocol

 5.3. Build a circuit evaluator
   - You can process a boolean circuit emulator, gate by gate, 
     similar to garbled circuit evaluation.
     Use the circuit input files from mp2.
"""    


#####################
# Sample test program
#####################

def test_program1(context):

    # Try opening an input value
    x = context.share_table['x']
    y = context.share_table['y']
    X = context.open_share(x)
    Y = context.open_share(y)
    assert type(X) is Fp
    # context.print('input value x was: ', X)

    # This would be a good sandbox to try out your own example code

    # Try opening a triple
    a, b, ab = context.get_triple_share()
    A, B, AB = context.open_share(a), context.open_share(b), context.open_share(ab)
    # context.print('A:', A)
    # context.print('B:', B)
    # context.print('AB:', AB)
    # context.print('A*B:', A*B)
    assert A*B == AB, "Opened triples did not match"


if __name__ == '__main__':
    # Sample program on easy mode (no corruptions)
    # This only relies on solutions in Problem 1 (polynomials.py)
    MPCSimulation(4, 1, dict(x=5, y=7), test_program1).run()

    ### MPC Programs

    # Problem 2.1: Beaver multiplication
    try:
        MPCSimulation(4, 1, dict(x=5, y=7), test_prog_beaver_multiply).run()
        print("2.1 passing")
    except Exception as e:
        print(e)

    # Problem 2.2: Computing inverses
    try:
        MPCSimulation(4, 1, dict(x=5, y=7), test_prog_inverses).run()
        print("2.2 passing")
    except Exception as e:
        print(e)

    # Problem 2.3: Generating random bits
    try:
        MPCSimulation(4, 1, dict(x=5, y=7), test_prog_random_bits).run()
        print("2.3 passing")
    except Exception as e:
        print(e)
        
    # Problem 2.4: Computing powers
    try:
        MPCSimulation(4, 1, dict(x=5, y=7), test_prog_constant_round_powers, preproc=80).run()
        print("2.4 passing")
    except Exception as e:
        print(e)

    # Problem 2.5: Random extraction
    try:
        MPCSimulation(4, 1, dict(x=5, y=7), test_prog_random_extract).run()
        print("2.5 passing")
    except Exception as e:
        print(e)
        
    ### Robust Reconstruction
        
    # Problem 3.1: Sample program on harder mode (crashed nodes)
    try:
        MPCSimulation(8, 2, dict(x=5, y=7), test_program1, crashed=True).run()
        print("3.1 passing")
    except Exception as e:
        print(e)

    # Problem 3.2: Sample program on harder mode (corrupted nodes)
    try:
        MPCSimulation(16, 5, dict(x=5, y=7), test_program1, corrupt=True).run()
        print("3.2 passing")
    except Exception as e:
        print(e)

    # Problem 3.3 (bonus): Sample program on much harder mode (lots of corrupted nodes)
    try:
        pass
        # MPCSimulation(40, 13, dict(x=5, y=7), test_program1, corrupt=True).run()
        # print("3.3 passing")
    except Exception as e:
        print(e)
